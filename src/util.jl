export getKatanaModel, getKatanaCuts, getKatanaSols

getKatanaModel(m :: KatanaNonlinearModel) = m
getKatanaModel(m :: MathProgBase.SolverInterface.NonlinearToLPQPBridge) = m.nlpmodel
getKatanaModel(m :: JuMP.Model) = getKatanaModel(internalmodel(m))

"""
    getKatanaCuts(m :: KatanaNonlinearModel)

Returns a table of all linear cutting planes generated by Katana's separation oracle. If the model contains `N` variables
(including an auxiliary variable) and `m` cutting planes were generated, the table will have size `m x (N+2)`.

For every row: the first `N` columns represent the coefficients of model variables, the `N+1`th column a constant term,
and the `N+2`th column an inequality direction (`-1` for ``\\leq`` and `1` for ``\\geq``). Thus, for coefficients ``a_1,\\ldots,a_N``, constant ``c`` and direction ``-1``, re-construct the cutting plane as ``a_{1}x_{1} + \\ldots + a_{N}x_{N} \\leq c``.
"""
function getKatanaCuts(m :: KatanaNonlinearModel)
    M = length(m.linear_cuts)
    N = m.num_var + 3 # coefficient for each variable + aux variable, constant and direction

    table = zeros(M,N)
    for (i,cut) in enumerate(m.linear_cuts)
        constr = LinearConstraint(cut)
        a = constr.terms
        for j in 1:length(a.vars)
            table[i,a.vars[j].col] += a.coeffs[j]
        end
        table[i,end-1] = JuMP.rhs(constr) # also checks this isn't a range constraint
        s = JuMP.sense(constr)
        @assert s != :(==) # wouldn't make sense to have equality constraint
        table[i,end] = s == :(<=) ? -1 : 1
    end

    return table
end

getKatanaSols(m :: KatanaNonlinearModel) = m.lp_sols

